<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WithoutHaste.Drawing.Shapes</name>
    </assembly>
    <members>
        <member name="T:WithoutHaste.Drawing.Shapes.Circle">
            <summary>
            A circle shape. Immutable.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.DEGREES_IN_CIRCLE">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.DEGREES_IN_HALF_CIRCLE">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.RADIANS_90DEGREES">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.RADIANS_180DEGREES">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.RADIANS_270DEGREES">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.RADIANS_360DEGREES">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.X">
            <summary>Center x coordinate.</summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.Y">
            <summary>Center y coordinate.</summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Circle.Radius">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Circle.Center">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Circle.Diameter">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Circle.MaxX">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Circle.MaxY">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Circle.MaxXDegrees">
            <summary>Based on coordinate plane, which degree points towards the MaxX coordinate?</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Circle.MaxYDegrees">
            <summary>Based on coordinate plane, which degree points towards the MaxY coordinate?</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.#ctor(System.Double,System.Double,System.Double)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.#ctor(WithoutHaste.Drawing.Shapes.Dot,System.Double)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.GetIntersectionPoints(WithoutHaste.Drawing.Shapes.Circle)">
            <summary>Finds the intersection points between the edge of this circle and circle <paramref name='b'/>.</summary>
            <returns>Null (no intersection), an array of length 1, or an array of length 2.</returns>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.GetTangentPoints(WithoutHaste.Drawing.Shapes.Dot)">
            <summary>
            Find the two tangent points on the circle that form lines to point <paramref name='b'/>.
            </summary>
            <returns>Array of length 2.</returns>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.Overlaps(WithoutHaste.Drawing.Shapes.Circle)">
            <summary>
            Returns true if any part of this circle overlaps any part of circle <paramref name='b'/>.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.Overlaps(WithoutHaste.Drawing.Shapes.LineSegment)">
            <summary>
            Returns true if any part of this circle overlaps any part of line segment <paramref name='b'/>.
            </summary>
            <remarks>
            If line <paramref name='b'/> lies within the circle, that counts as overlapping.
            </remarks>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.ContainsOrIsContained(WithoutHaste.Drawing.Shapes.Circle)">
            <summary>
            Returns true if this circle entirely contains circle <paramref name='b'/>, or <paramref name='b'/> entirely contains this circle, or they exactly overlap.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.Contains(WithoutHaste.Drawing.Shapes.Circle)">
            <summary>
            Returns true if this circle entirely contains circle <paramref name='b'/>, or they exactly overlap.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.Contains(WithoutHaste.Drawing.Shapes.Wedge)">
            <summary>
            Returns true if this circle entirely contains wedge <paramref name='b'/>.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.Contains(WithoutHaste.Drawing.Shapes.Dot)">
            <summary>
            Returns true if point <paramref name='b'/> lies within or on this circle.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.PointAtRadians(System.Double)">
            <summary>
            Returns the point on this circle at the <paramref name='radians'/> measurement. 
            0 radians is East of center, increases clockwise.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.PointAtDegrees(System.Double)">
            <summary>
            Returns the point on this circle at the <paramref name='degrees'/> measurement. 
            0 degrees is East of center, increases clockwise.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.DegreesAtPoint(WithoutHaste.Drawing.Shapes.Dot)">
            <summary>
            Given a line from the center of this circle to a point (<paramref name='lineEnd'/>), what degrees is the line angle at? 
            0 degrees is East of center, increases clockwise.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.GetIntersectionPoints(WithoutHaste.Drawing.Shapes.Line)">
            <returns>Null (no intercepts), or array of length 1 or 2.</returns>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.GetIntersectionPoints(WithoutHaste.Drawing.Shapes.LineSegment)">
            <summary>Find the intersection points between the edge of this circle and the <paramref name='lineSegment'/>.</summary>
            <returns>Null (no intercepts), or array of length 1, or array of length 2.</returns>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.DegreesToRadians(System.Double)">
            <summary>
            Convert degrees to radians.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.RadiansToDegrees(System.Double)">
            <summary>
            Convert radians to degrees.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.op_Division(WithoutHaste.Drawing.Shapes.Circle,System.Double)">
            <summary>
            Scale circle down by <paramref name='b'/> amount. Affects length and location measures.
            </summary>
            <example><c>circle / 2</c> returns a new Circle with half the radius and half the distance from point (0,0).</example>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.op_Equality(WithoutHaste.Drawing.Shapes.Circle,WithoutHaste.Drawing.Shapes.Circle)">
            <summary>Circle centers and radiuses are the same.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.op_Inequality(WithoutHaste.Drawing.Shapes.Circle,WithoutHaste.Drawing.Shapes.Circle)">
            <summary>Circle centers or radiuses are different.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.Equals(System.Object)">
            <duplicate cref='M:WithoutHaste.Drawing.Shapes.Circle.op_Equality(WithoutHaste.Drawing.Shapes.Circle,WithoutHaste.Drawing.Shapes.Circle)'/>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.ToString">
            <summary>Format "C:(x,y) R:radius"</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Circle.Paint(System.Drawing.Graphics,System.Drawing.Pen,System.Double)">
            <inheritdoc/>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.Geometry">
            <summary>
            Global settings and miscellaneous operations.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.MarginOfError">
            <summary>
            When determining equality, all values have a +/- margin of error. This setting is used in all Shape operations that check equality.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.CoordinatePlane">
            <summary>
            This coordinate plane is used in all Shape operations that require one.
            </summary>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.Geometry.CoordinatePlanes">
            <summary>
            Determines how cardinal directions apply to coordinates.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.CoordinatePlanes.None">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.CoordinatePlanes.Screen">
            <summary>
            Computer screens have (0,0) in the upper-left corner and increase to the right and down.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.CoordinatePlanes.Paper">
            <summary>
            Paper graphs have (0,0) in the lower-left corner and increase to the right and up.
            </summary>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.Geometry.Direction">
            <summary>
            Cardinal directions.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.None">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.East">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.SouthEast">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.South">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.SouthWest">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.West">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.NorthWest">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.North">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Geometry.Direction.NorthEast">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Geometry.WithinMarginOfError(System.Double,System.Double)">
            <summary>Check if values are equal, within the MarginOfError.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Geometry.PointOnLine(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot,System.Double)">
            <summary>
            Calculates point along line AB, starting at A and moving towards B
            </summary>
            <exception cref='T:System.ArgumentException'>Point A and B cannot be the same.</exception>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Geometry.PointPastLine(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot,System.Double)">
            <summary>
            Calculates point along line AB, starting at B and moving away from A
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Geometry.LineDirection(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <summary>
            Given directed line A to B, what direction is it pointing?
            </summary>
            <remarks>
            North, South, East, and West answers are exact. So "North" means exactly North.
            The inbetween directions cover all remaining values. So "NorthWest" covers all values between North and West.
            </remarks>
            <exception cref='T:System.NotImplementedException'>Coordinate plane not supported.</exception>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.IDraw">
            <summary>
            Represents anything that can be drawn on a Graphics object.
            </summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.IDraw.MaxX">
            <summary>Maximum x coordinate required to draw the figure.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.IDraw.MaxY">
            <summary>Maximum y coordinate required to draw the figure.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.IDraw.Paint(System.Drawing.Graphics,System.Drawing.Pen,System.Double)">
            <summary>
            Draw the figure on the <paramref name='graphics'/> with the <paramref name='pen'/>.
            </summary>
            <param name="unitsToPixels">
            Conversion ratio from figure units to pixels. A value of "2" means all figure measurements will be doubled.
            </param>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.Line">
            <summary>
            Line of infinite length passing through points A and B. Immutable.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Line.A">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Line.B">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Line.IsDirected">
            <summary>
            When directed, the direction is A to B.
            </summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Line.Slope">
            <summary>Slope assumes direction from A to B.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Line.PerpendicularSlope">
            <summary>Slope of line perpendicular to this one.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Line.YIntercept">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Line.IsVertical">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Line.IsHorizontal">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Line.#ctor(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <exception cref='T:System.ArgumentException'>Points A and B cannot be the same.</exception>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Line.#ctor(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot,System.Boolean)">
            <exception cref='T:System.ArgumentException'>Points A and B cannot be the same.</exception>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Line.ToLineSegment">
            <summary>Convert to <see cref="T:WithoutHaste.Drawing.Shapes.LineSegment"/>.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Line.GetPerpendicularIntersect(WithoutHaste.Drawing.Shapes.Dot)">
            <summary>
            Returns the point where a perpendicular line passing through point <paramref name='c'/> intersects this line.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Line.op_Division(WithoutHaste.Drawing.Shapes.Line,System.Double)">
            <summary>
            Scale line down by <paramref name='b'/> amount. Affects length and location measures.
            </summary>
            <example><c>line / 2</c> returns a new Line that lies halfway between point (0,0) and this line.</example>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Line.ToString">
            <summary>Format "(A.x,A.y) to (B.x,B.y)"</summary>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.LineSegment">
            <summary>
            Line segment from point A to point B. Immutable.
            </summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.LineSegment.MaxX">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.LineSegment.MaxY">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.LineSegment.Length">
            <summary>Distance between points A and B. Always positive.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.LineSegment.#ctor(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.LineSegment.#ctor(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.LineSegment.ToLine">
            <summary>Convert to <see cref="T:WithoutHaste.Drawing.Shapes.Line"/>.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.LineSegment.Overlaps(WithoutHaste.Drawing.Shapes.Dot)">
            <summary>Returns true if point <paramref name='c'/> lies on this line segment.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.LineSegment.Overlaps(WithoutHaste.Drawing.Shapes.LineSegment)">
            <summary>Returns true if this line segments overlaps line segment <paramref name='b'/> at any point.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.LineSegment.ToString">
            <summary>Format "(A.x,A.y) to (B.x,B.y)"</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.LineSegment.Paint(System.Drawing.Graphics,System.Drawing.Pen,System.Double)">
            <inheritdoc/>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.Dot">
            <summary>
            An (X, Y) coordinate. Immutable.
            </summary>
            <remarks>
            It's called "Dot" so as not to conflict with System.Drawing.Point. Points use integer coordinates, these Dots use doubles.
            
            I'm considering changing all the names to use a common suffix character for differentiation, instead of synonyms.
            Such as "WPoint, WCircle, WLineSegment" instead of "Dot, Circle, LineSegment".
            </remarks>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Dot.X">
            <summary></summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Dot.Y">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Dot.MaxX">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Dot.MaxY">
            <inheritdoc/>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.#ctor(System.Double,System.Double)">
            <param name="x">Cannot be NaN or Infinity.</param>
            <param name="y">Cannot be NaN or Infinity.</param>
            <exception cref="T:System.ArgumentException">X or Y was NaN or Infinity.</exception>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.Distance(WithoutHaste.Drawing.Shapes.Dot)">
            <summary>
            Returns the distance between this point and point <paramref name='b'/>. Always positive.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.Overlaps(WithoutHaste.Drawing.Shapes.LineSegment)">
            <summary>Returns true if this point overlaps any part of the <pararef name='lineSegment'/>.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_Addition(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_Subtraction(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_Multiply(System.Double,WithoutHaste.Drawing.Shapes.Dot)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_Multiply(WithoutHaste.Drawing.Shapes.Dot,System.Double)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_Division(System.Double,WithoutHaste.Drawing.Shapes.Dot)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_Division(WithoutHaste.Drawing.Shapes.Dot,System.Double)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_LessThan(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <summary>
            Greater than/less than is judged along the x-axis first, then the y-axis
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_GreaterThan(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <duplicate cref='M:WithoutHaste.Drawing.Shapes.Dot.op_LessThan(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)'/>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_Equality(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.op_Inequality(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.Dot)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.Equals(System.Object)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.ToString">
            <summary>Format "(X,Y)"</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Dot.Paint(System.Drawing.Graphics,System.Drawing.Pen,System.Double)">
            <inheritdoc/>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.Range">
            <summary>
            A linear range of values. Immutable.
            </summary>
            <remarks>
            Ranges are inclusive: both the Start and the End values are included in the range.
            </remarks>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Range.Start">
            <summary>
            For non-circular ranges, operations assume that Start is the minimum value.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Range.End">
            <summary></summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Range.Span">
            <summary>End minus Start.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Range.Middle">
            <summary>Middle value between Start and End.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.#ctor(System.Double,System.Double)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.Centered(System.Double,System.Double)">
            <summary>Create a range with this span and middle value.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.Overlaps(WithoutHaste.Drawing.Shapes.Range)">
            <summary>Returns true if this range overlaps range <paramref name='b'/>.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.Overlaps(System.Double)">
            <summary>Returns true if this range includes value <paramref name='b'/>.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.ConvertValue(WithoutHaste.Drawing.Shapes.Range,WithoutHaste.Drawing.Shapes.Range,System.Double)">
            <summary>
            Convert the <paramref name='value'/> in <paramref name='originalRange'/> to one in <paramref name='newRange'/>.
            </summary>
            <remarks>
            Essentially, <paramref name='originalRange'/> is scaled up or down to match <paramref name='newRange'/>.
            So the returned value is the same percentage along <paramref name='newRange'/> as the provided <paramref name='value'/> was along <paramref name='originalRange'/>.
            </remarks>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.ToString">
            <summary>Format "Start-End".</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.op_Addition(WithoutHaste.Drawing.Shapes.Range,WithoutHaste.Drawing.Shapes.Range)">
            <summary>
            Returns a range that covers all the area both <paramref name='a'/> and <paramref name='b'/> cover, including any gap in between.
            This operation is commutative.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.op_Equality(WithoutHaste.Drawing.Shapes.Range,WithoutHaste.Drawing.Shapes.Range)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.op_Inequality(WithoutHaste.Drawing.Shapes.Range,WithoutHaste.Drawing.Shapes.Range)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.Equals(System.Object)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Range.GetHashCode">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.RangeCircular">
            <summary>
            A range on a circular scale. Immutable.
            </summary>
            <remarks>
            A circular scale can be written shorthand as [0, CircularModulus), meaning 0 is included in the scale and CircularModulus is excluded from the scale.
            
            The range may cover the entire scale, or only a portion of the scale.
            To cover the entire scale, set Start and End to the same value.
            
            Throughout the documentation, "scale" refers to the full circular scale [0, CircularModulus) while "range" refers to a subset of values [Start, End].
            </remarks>
            <example>
            The degrees of a circle make up a circular scale [0, 360).
            The range may only cover [25, 45] of the scale [0, 360).
            In this case, Start=25, End=45, and CircularModulus=360.
            </example>
            <example>
            The hours of a clock make up a circular range [1, 13) for a normal clock, or [0, 24) for a military clock.
            Since RangeCircular always starts at 0, the normal clock would need to be represented as [0, 12). You'd need to handle the +1 offset when setting or displaying values.
            </example>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.RangeCircular.CircularModulus">
            <summary>The value at which the range loops back to 0.</summary>
            <remarks>In the context of this range, 0 and CircularModulus are the same value.</remarks>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.RangeCircular.Span">
            <summary>Distance from Start to End.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.RangeCircular.Middle">
            <summary>Middle value between Start and End.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.#ctor(System.Double,System.Double,System.Int32)">
            <exception cref='T:System.ArgumentException'>CircularModulus must be greater than 0.</exception>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.Centered(System.Double,System.Double,System.Int32)">
            <exception cref='T:System.ArgumentException'>CircularModulus must be greater than 0.</exception>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.Overlaps(WithoutHaste.Drawing.Shapes.RangeCircular)">
            <summary>Returns true if this range overlaps range <paramref name='b'/>.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.Overlaps(System.Double)">
            <summary>Returns true if this range includes value <paramref name='b'/>.</summary>
            <remarks>
            <paramref name='b'/> is first put in context of this scale [0, CircularModulus).
            
            For example:
            Value 13 on scale [0, 24) is converted to value 1 when compared to scale [0, 12) because <c>13 modulus 12 = 1</c>.
            Value 13 therefore does overlap range [0, 3] on scale [0, 12), but does not overlap range [2, 3] on scale [0, 12).
            </remarks>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.op_Addition(WithoutHaste.Drawing.Shapes.RangeCircular,WithoutHaste.Drawing.Shapes.RangeCircular)">
            <summary>
            Returns a range that covers all the area both <paramref name='a'/> and <paramref name='b'/> cover, including any gap in between.
            If the ranges overlap, there is no gap filled in.
            </summary>
            <remarks>
            Gaps are covered from direction <paramref name='a'/> to <paramref name='b'/>, therefore this operation is not commutative.
              <example>
              Consider range A is [0, 45] on scale [0, 360), and range B is range [90, 180] on scale [0, 360).
              A + B = range [0, 180] on scale [0, 360) which has a Span of 180.
              B + A = range [90, 45] on scale [0, 360) which has a Span of 315.
              </example>
            </remarks>
            <exception cref='T:System.ArgumentException'>RangeCirculars with different CircularModulus values cannot be combined.</exception>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.Mod(System.Double)">
            <summary>Convert a number into this scale. Ensures a positive result.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.Mod(System.Double,System.Int32)">
            <summary>
            Returns <paramref name='number'/> modulus <paramref name='m'/>. Ensures a positive result.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.op_Equality(WithoutHaste.Drawing.Shapes.RangeCircular,WithoutHaste.Drawing.Shapes.RangeCircular)">
            <summary>Circular ranges are equal if they have the same scale and same range, meaning the Start, End, and CircularModulus values are all the same.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.op_Inequality(WithoutHaste.Drawing.Shapes.RangeCircular,WithoutHaste.Drawing.Shapes.RangeCircular)">
            <duplicate cref='M:WithoutHaste.Drawing.Shapes.RangeCircular.op_Equality(WithoutHaste.Drawing.Shapes.RangeCircular,WithoutHaste.Drawing.Shapes.RangeCircular)'/>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.Equals(System.Object)">
            <duplicate cref='M:WithoutHaste.Drawing.Shapes.RangeCircular.op_Equality(WithoutHaste.Drawing.Shapes.RangeCircular,WithoutHaste.Drawing.Shapes.RangeCircular)'/>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.RangeCircular.GetHashCode">
            <summary></summary>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.Shape">
            <summary>Represents a shape, a geometrical figure, a form.</summary>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.Wedge">
            <summary>
            A wedge is a slice of a circle. It is also known as a circular sector. Immutable.
            </summary>
            <remarks>
            "Arc" refers to the segment of circle's circumference that makes up the curved edge of the wedge. And arc is 1-dimensional; an arc is a curved line.
            </remarks>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.Wedge.Radius">
            <summary>The radius of the full circle this wedge is a slice of. Also the length of either straight side of the wegde.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Wedge.Circle">
            <summary>The full circle that this wedge is a part of.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Wedge.StartPoint">
            <summary>The point on circumference of Circle where the wedge begins.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Wedge.EndPoint">
            <summary>The point on circumference of Circle where the wedge ends.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Wedge.ArcPoint">
            <summary>The point at the middle of the arc edge of the wedge.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Wedge.FourPoints">
            <summary>
            The boundary points of the wedge:
             <list type="bullet">
              <item>Center</item>
              <item>StartPoint</item>
              <item>EndPoint</item>
              <item>ArcPoint</item>
             </list>
            </summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Wedge.LineEdges">
            <summary>
            The straight edges of the wedge:
             <list type="bullet">
              <item>Center to StartPoint</item>
              <item>Center to EndPoint</item>
             </list>
            </summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Wedge.MaxX">
            <inheritdoc/>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.Wedge.MaxY">
            <inheritdoc/>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.#ctor(WithoutHaste.Drawing.Shapes.Circle,WithoutHaste.Drawing.Shapes.RangeCircular)">
            <param name="circle">The full circle this wedge is a part of.</param>
            <param name="degreeRange">The range of degrees this wedge covers.</param>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.#ctor(WithoutHaste.Drawing.Shapes.Circle,System.Double,System.Double)">
            <param name="circle">The full circle this wedge is a part of.</param>
            <param name="degreeStart">The starting degree the wedge covers.</param>
            <param name="degreeEnd">The ending degree the wedge covers.</param>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.Overlaps(WithoutHaste.Drawing.Shapes.Circle)">
            <summary>
            Returns true if any part of this wedge overlaps any part of circle <paramref name='b'/>.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.Overlaps(WithoutHaste.Drawing.Shapes.Wedge)">
            <summary>
            Returns true if any part of this wedge overlaps any part of wedge <paramref name='b'/>.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.ArcOverlaps(WithoutHaste.Drawing.Shapes.LineSegment)">
            <summary>
            Returns true if the arc overlaps any part of the <paramref name='lineSegment'/>.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.ArcOverlapsArc(WithoutHaste.Drawing.Shapes.Wedge)">
            <summary>
            Returns true if this arc overlaps any part of <paramref name='b'/>'s arc.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.Contains(WithoutHaste.Drawing.Shapes.Circle)">
            <summary>
            Returns true if this wedge fully contains circle <paramref name='b'/>.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.Contains(WithoutHaste.Drawing.Shapes.Dot)">
            <summary>
            Returns true if this wedge contains point <paramref name='b'/>, including if <paramref name='b'/> lies on one of this wedge's edges.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.op_Division(WithoutHaste.Drawing.Shapes.Wedge,System.Double)">
            <summary>
            Scale wedge down by <paramref name='b'/> amount. Affects length and location measures, but not degrees.
            </summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.Paint(System.Drawing.Graphics,System.Drawing.Pen,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.Wedge.ToString">
            <summary>Format "C:(X,Y) R:Radius Degrees:Start-End".</summary>
        </member>
        <member name="T:WithoutHaste.Drawing.Shapes.WedgeUnbound">
            <summary>
            A wedge is a slice of a circle. An unbounded wedge is a slice of circle that extends outward from the center with no limit. Immutable.
            </summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.WedgeUnbound.Center">
            <summary>Center of the circle that defines this wedge.</summary>
        </member>
        <member name="F:WithoutHaste.Drawing.Shapes.WedgeUnbound.Degrees">
            <summary>The degrees of the defining circle that this wedge extends through.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.WedgeUnbound.Span">
            <summary>The total degrees this wedge covers.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.WedgeUnbound.Start">
            <summary>Starting degree.</summary>
        </member>
        <member name="P:WithoutHaste.Drawing.Shapes.WedgeUnbound.End">
            <summary>Ending degree.</summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.WedgeUnbound.#ctor(WithoutHaste.Drawing.Shapes.Dot,WithoutHaste.Drawing.Shapes.RangeCircular)">
            <summary></summary>
        </member>
        <member name="M:WithoutHaste.Drawing.Shapes.WedgeUnbound.#ctor(WithoutHaste.Drawing.Shapes.Dot,System.Double,System.Double)">
            <summary></summary>
        </member>
    </members>
</doc>
